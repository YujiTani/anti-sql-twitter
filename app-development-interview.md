# アプリケーション開発の面接質問

駆け出しエンジニア向けにSQLのパフォーマンスチューニング練習ができるアプリケーションを作成したいです。
アプリケーションの内容としては、XのようなSNSにしたいと考えています。

## 理由

- 自身がSNSの仕組みを理解できるようになりたい
- 比較的データが追加しやすいと考えられる（データ追加は一定時間ごとにランダム発生のcronイベントで行いたいと考えています。）

## アプリ内容

- 今のxよりももう少しUIを凝ったものにしたい（xほどのユーザー数にはならないため、アニメーションやユニークなUIで差別化したい）
- アプリケーションを実際に使うのは、ユーザーが作成した仮想ユーザーにしたい。プロパティは以下のようにしたい
  - 仮想ユーザー名
  - 性格（ツイート内容や、フォロー傾向に影響）
  - 性別（口調に影響）
  - 趣味（ツイート内容や、フォロー傾向に影響）
  - 活動時間帯（朝型、昼型、夜型）
- 文字だけの世界のシムシティみたいにしたい
- ユーザーのできること
  - 仮想ユーザー作成
  - 仮想ユーザーのデータを見れる（ツイート履歴、フォロー情報、フォロワー情報）
  - 興味の傾向
  - 仮想ユーザーの行動確率を調整（「積極的」「消極的」等の抽象的表現で、内部的に確率を変更）
- 仮想ユーザーには、現実世界のニュース情報などが与えられる（週1回取得）

## 仮想ユーザーの自動行動

- **ツイート**：最低1日1回、性格と活動時間帯によりランダム頻度で投稿
- **フォロー関係**：性格・趣味・活動時間帯の類似度によってフォロー確率が変動、自動でフォロー/フォロー解除
- **リアクション**：いいね、リツイート、リプライを自動実行
- **ニュースへの反応**：性格に応じてニュースにリアクション
- **相互作用**：他ユーザーのツイートへの反応も性格により自動実行
- **AI判定**：OpenAI APIを使用してフォロー判定、リツイート判定、ツイート生成を実行

## 技術スタック

- フロントエンド
  - React
  - TypeScript
  - Tailwind CSS（一部では、生のCSSもかけるような作りにしたい）
- バックエンド
  - Node.js
  - Hono
  - supabase（データベースとして使用）
    - PostgreSQL
  - Prisma（永続化処理とオブジェクトマッピングに使用、ただしクエリービルダーは使わずにSQLで記述）
- Auth
  - supabaseのAuth
- CI/CD
  - GitHub Actions
- デプロイ
  - Vercel
- その他
  - Docker
  - OpenAI API（ニュース情報の取得、ツイート内容の生成、フォロー判定、リツイート判定に使用）
- テスト
  - Playwright（E2Eテスト）
  - Vitest（ユニットテスト）
- ドキュメント
  - Markdown（READMEやWiki）
  - Swagger（APIドキュメント）
- コード品質
  - ESLint
  - Biome
  - TypeScriptの型チェック
  - Commitlint（コミットメッセージのチェック）
  - Husky（Gitフックの設定）
- ログ
  - Sentry（エラーログの収集）
- モニタリング
  - SQLのモニタリングができるように毎日集計データが見れるようにして欲しい
- セキュリティ
  - OWASPのベストプラクティスに従う
  - SQLインジェクション対策
  - XSS対策
  - CSRF対策
- パフォーマンス
  - Lighthouseでのパフォーマンスチェック
  - 画像の最適化
  - レイジーロードの実装
- 国際化
  - i18nextを使用して多言語対応
  - 翻訳ファイルの管理
- SEO
  - メタタグの設定
  - サイトマップの生成
- ユーザビリティ
  - ユーザーテストの実施
  - フィードバックの収集
  - ユーザーインタビューの実施
- ドキュメント
  - READMEの作成
  - Wikiの作成
  - APIドキュメントの作成
  - コードコメントの充実
- コミュニティ
  - GitHub Discussionsの活用
  - Issueテンプレートの作成
  - Pull Requestテンプレートの作成

## SQLパフォーマンス学習の設計方針

- **意図的な非効率化**：学習効果を高めるため、以下の問題を意図的に組み込む
  - テーブル設計の正規化不足
  - 適切なインデックスの不足
  - SQLアンチパターンの実装（N+1問題、不適切なJOIN等）
- **パフォーマンス測定**：SQLクエリの実行時間やEXPLAIN結果を可視化
- **データ量**：ローカル環境で100万行程度のデータでパフォーマンス差を体感できるように設計
- **学習段階**：改善計画はユーザーに委ね、開発者側では学習段階を考慮しない

## 利用想定とデプロイ方針

- **デモ版本番リリース**：機能を体験できるデモ版をVercelにデプロイ
- **学習環境**：開発者が各自のGitHubでfork/cloneして、ローカル環境で改善学習を実施
- **UI/UX**：リアルタイム機能は実装せず、管理ダッシュボードは低優先度で対応
